## 엘레강트 오브젝트 스터디 2회차 피드백 정리
- 자바/코틀린 등 언어적인 관점에서 보지 말자. 
- 프로그래밍적/객체지향적 관점에서 더 생각해보기.
- 책 내용에 반대하더라도, 일단은 수용하고 시도해보려고 노력하자. (저자가 우리보다 개발을 잘 함)

<br>

### 상태 = 식별자
- `Cash(dollars, cent)`
- dollars, cent 두 상태를 하나의 "복합 키"로 보는 것과 동일하다.
	- 복합 키: 2개 이상의 컬럼을 1개의 후보 키로 만들어 기본 키로 활용되는 키
- 기술적으로 보지 않고, "개념적으로"만 봤을 때 `Cash(1, 25)`와 `Cash(1, 25)`는 같다.
- 값 객체
	- String, Int는 수많은 문자열과 정수를 포함하기 때문에 도메인에서 포괄적인 타입이다.
	- 값 객체를 이용해서 도메인에 특정된 값을 이용하자.

<br>

### static은 왜 나쁜가?
- '언어에서 제공하기 때문에 나쁜 것이 아니다'라는 생각을 버리기!
- static은 주체가 없다. 즉, "누가" 무엇을 하는지가 빠져있기 때문에 절차지향적인 코드라고 할 수 있다.
- 객체지향 -> `누가.무엇을()`
- 함수형 -> `무엇을(누가)`

<br>

### 항상 인터페이스를 사용하라
- RDD(책임 주도 설계)
	- "상태"는 "행동"을 정하면 저절로 따라오는 것이다. 즉, 행동을 먼저 생각한다.
	- RDD를 하기 위해서는, 인터페이스를 만들어야 한다.
	- `인터페이스를 먼저 만든다.` == `행동을 먼저 생각한다. (= public method)` == `책임을 먼저 생각한다.` == `객체지향적 코드가 된다.`

\+ 추후 BDD((Behavior Driven Development, 행동 주도 개발)를 배울 것이다. 행동을 먼저 생각하는 방식인데, 여기서 말하는 "행동"이 곧 인터페이스가 된다.

<br>

### 빌더와 조정자
```kotlin
class Cash(private val cent: Int) {
  fun mul(cent: Int): Cash {
    return Cash(this.cent * cent)
  }
}
```
- 가변 객체에 대해서만 빌더와 조정자를 명확히 구분할 수 있다. 즉, 위 코드의 `Cash`는 불변 객체이며, `mul()`은 빌더다.
- 코틀린에서 `빌더와 조정자`를 적용할 수 있는 세 가지
	- 프로퍼티 - 항상 빌더이기 때문에 명사로 짓는다.
	- 함수 - 빌더
	- 함수 - 조정자
- CQS 공부해보기

<br>

### 퍼블릭 상수
- static 메서드와 필드는 좋지 않다고 배웠다.
- 즉, static 필드가 퍼블릭 상수이기 때문에 지양해야 한다!
- 열거형은?
  - enum은 상수의 집합이 아닌, 상수 "객체"의 집합이다.
  - 코틀린은 `enum class`로 선언하지만, 자바는 enum 키워드로만 선언하기 때문에 열거형을 일반적인 상수로 보기 쉽다.
  - 하지만 enum도 객체의 일종이다. 

<br>

### 테스트, 문서화
- 문서화는 일반적으로 설계에 대한 명세를 작성한다. 설계가 변화했을 때 문서를 수정하지 않으면, 결국 죽은 문서가 된다.
	- 즉, 살아있는 문서는 테스트가 된다. 
	- 테스트도 유지보수해야 할 대상이다.
- 애자일이 생기게 된 계기
	- 애자일, 스크럼, 칸반보드, XP 등은 waterfall 처럼 완벽하게 하지 않고, 빠른 사이클을 반복하기 위해 생겨났다.
	- 이 빠른 사이클을 문서화하기 위해 나타난 것이 TDD이다.
	- 테스트를 먼저 작성한다고 해서 TDD가 아니라, 테스트를 작성함으로써 자신이 안정감을 얻을 수만 있다면 TDD다!

<br>

### Mock vs Fake
- 실제 존재하는 것으로 테스트하는 것 -> Fake
- given-when-then의 given을 명세하기 위해서는 Mock이 필요하다.
- Mock이 비판받는 주된 이유
	- 블랙박스 테스트가 아니기 때문이다.
	- 리플렉션을 사용하여 상대적으로 속도가 느리다.

<br>

### 스마트 클래스
- 인터페이스는 상호작용을 하기 위한 범용적인 계약이다.
- 처음 인터페이스를 설계할 때는, 인터페이스의 책임이 적을 수 있다. 하지만 개발하다보면 인터페이스의 할 일이 늘어날 수 있는데, 이를 도와주는 도구가 스마트 클래스다.
